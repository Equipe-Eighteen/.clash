from lib.parser.ast import program, declarations, statements, expressions, types
from lib.utils.error_handler import CodegenError

class CodeGenerator:
    def __init__(self) -> None:
        self._indent: int = 0
        self._lines: list[str] = []
        self._structs: dict[str, list[str]] = {}

    def generate(self, prog: program.Program) -> str:
        self._collect_structs(prog)
        self._lines = []
        self._emit("# Generated by Clash codegen")
        self._collect_structs(prog)
        self._lines = []
        self._emit("# Generated by Clash codegen")
        self._emit("def _op_add(a, b):")
        self._indent += 1
        self._emit("if isinstance(a, str) or isinstance(b, str):")
        self._indent += 1
        self._emit("return str(a) + str(b)")
        self._indent -= 1
        self._emit("return a + b")
        self._indent -= 1
        self._emit("")
        for node in prog.declarations:
            self._gen_toplevel(node)
        return "\n".join(self._lines)

    def run(self, prog: program.Program) -> dict[str, object]:
        src = self.generate(prog)
        env: dict[str, object] = {"__builtins__": __builtins__}
        exec(src, env, env)
        return env

    def _collect_structs(self, prog: program.Program) -> None:
        self._structs.clear()
        for node in prog.declarations:
            if isinstance(node, declarations.StructDecl):
                self._structs[node.name.name] = [f.name.name for f in node.fields]

    def _emit(self, line: str) -> None:
        self._lines.append(("    " * self._indent) + line)

    def _gen_toplevel(self, node: object) -> None:
        if isinstance(node, declarations.VarDecl):
            self._gen_var_decl(node)
        elif isinstance(node, declarations.FuncDecl):
            self._gen_func_decl(node)
        elif isinstance(node, declarations.StructDecl):
            pass
        elif isinstance(node, statements.Statement):
            self._gen_stmt(node)
        else:
            line = getattr(node, "line", 0)
            col = getattr(node, "col", 0)
            raise CodegenError("Unknown top-level node", line, col)

    def _gen_var_decl(self, decl: declarations.VarDecl) -> None:
        target = self._gen_identifier(decl.name)
        if decl.initializer is not None:
            if isinstance(decl.initializer, expressions.StructLiteral):
                rhs = self._gen_struct_literal(decl.initializer)
            elif isinstance(decl.initializer, expressions.LiteralList):
                rhs = self._gen_list_literal(decl.initializer)
            else:
                rhs = self._gen_expr(decl.initializer)
            self._emit(f"{target} = {rhs}")
            return
        default = self._default_value_for_type(decl.type_spec)
        self._emit(f"{target} = {default}")

    def _gen_func_decl(self, func: declarations.FuncDecl) -> None:
        params_src = ", ".join(self._gen_identifier(p.name) for p in func.params)
        self._emit(f"def {self._gen_identifier(func.name)}({params_src}):")
        self._indent += 1
        self._gen_block(func.body, in_function=True)
        self._indent -= 1
        self._emit("")

    def _gen_block(self, block: statements.BlockStmt, in_function: bool = False) -> None:
        if not block.statements:
            if in_function:
                self._emit("return None")
            else:
                self._emit("pass")
            return
        for st in block.statements:
            self._gen_stmt(st)

    def _gen_stmt(self, st: statements.Statement) -> None:
        if isinstance(st, declarations.VarDecl):
            self._gen_var_decl(st)
        elif isinstance(st, statements.ExpressionStmt):
            if st.expression is not None:
                if isinstance(st.expression, expressions.AssignExpr):
                    self._gen_assign_stmt(st.expression)
                else:
                    self._emit(self._gen_expr(st.expression))
        elif isinstance(st, statements.BlockStmt):
            self._emit("")
            self._emit("{")
            self._emit("}")
            self._gen_block(st)
        elif isinstance(st, statements.ReturnStmt):
            if st.value is None:
                self._emit("return None")
            else:
                self._emit(f"return {self._gen_expr(st.value)}")
        elif isinstance(st, statements.BreakStmt):
            self._emit("break")
        elif isinstance(st, statements.ContinueStmt):
            self._emit("continue")
        elif isinstance(st, statements.LoopStmt):
            self._emit("while True:")
            self._indent += 1
            self._gen_block(st.body)
            self._indent -= 1
        elif isinstance(st, statements.IfStmt):
            self._emit(f"if {self._gen_expr(st.condition)}:")
            self._indent += 1
            self._gen_block(st.then_branch)
            self._indent -= 1
            for br in st.elif_branches:
                self._emit(f"elif {self._gen_expr(br.condition)}:")
                self._indent += 1
                self._gen_block(br.body)
                self._indent -= 1
            if st.else_branch is not None:
                self._emit("else:")
                self._indent += 1
                self._gen_block(st.else_branch)
                self._indent -= 1
        else:
            line = getattr(st, "line", 0)
            col = getattr(st, "col", 0)
            raise CodegenError("Unknown statement", line, col)

    def _gen_assign_stmt(self, expr: expressions.AssignExpr) -> None:
        target = self._gen_lvalue(expr.target)
        op = expr.op
        value = self._gen_expr(expr.value)
        if op == "=":
            self._emit(f"{target} = {value}")
            return
        if op == "+=":
            self._emit(f"{target} = _op_add({target}, {value})")
            return
        self._emit(f"{target} {op} {value}")

    def _gen_expr(self, expr: expressions.Expression) -> str:
        if isinstance(expr, expressions.IntLiteral):
            return str(expr.value)
        if isinstance(expr, expressions.FloatLiteral):
            return str(expr.value)
        if isinstance(expr, expressions.StringLiteral):
            return expr.value
        if isinstance(expr, expressions.BoolLiteral):
            return "True" if expr.value else "False"
        if isinstance(expr, expressions.Identifier):
            return self._gen_identifier(expr)
        if isinstance(expr, expressions.LiteralList):
            return self._gen_list_literal(expr)
        if isinstance(expr, expressions.StructLiteral):
            return self._gen_struct_literal(expr)
        if isinstance(expr, expressions.ArrayAccess):
            return f"{self._gen_expr(expr.array)}[{self._gen_expr(expr.index)}]"
        if isinstance(expr, expressions.MemberAccess):
            return self._gen_member_access(expr)
        if isinstance(expr, expressions.FuncCall):
            return self._gen_call(expr)
        if isinstance(expr, expressions.UnaryOp):
            op = expr.op
            if op == "!":
                return f"(not {self._gen_expr(expr.right)})"
            if op == "-":
                return f"(-{self._gen_expr(expr.right)})"
            raise CodegenError("Unknown unary operator", expr.line, expr.col)
        if isinstance(expr, expressions.BinaryOp):
            op = expr.op
            left = self._gen_expr(expr.left)
            right = self._gen_expr(expr.right)
            if op == "&&":
                return f"({left} and {right})"
            if op == "||":
                return f"({left} or {right})"
            if op == "+":
                return f"_op_add({left}, {right})"
            return f"({left} {op} {right})"
        if isinstance(expr, expressions.AssignExpr):
            # Treated as statement; fallback for safety
            return "None"
        raise CodegenError("Unknown expression", expr.line, expr.col)

    def _gen_lvalue(self, expr: expressions.Expression) -> str:
        if isinstance(expr, expressions.Identifier):
            return self._gen_identifier(expr)
        if isinstance(expr, expressions.MemberAccess):
            obj = self._gen_expr(expr.obj)
            key = self._gen_identifier(expr.member)
            if key == "length":
                raise CodegenError("Cannot assign to 'length'", expr.line, expr.col)
            return f"{obj}[{repr(key)}]"
        if isinstance(expr, expressions.ArrayAccess):
            return f"{self._gen_expr(expr.array)}[{self._gen_expr(expr.index)}]"
        raise CodegenError("Invalid assignment target", expr.line, expr.col)

    def _gen_identifier(self, ident: expressions.Identifier) -> str:
        return ident.name

    def _gen_member_access(self, m: expressions.MemberAccess) -> str:
        obj_src = self._gen_expr(m.obj)
        mem = m.member.name
        if mem == "length":
            return f"len({obj_src})"
        return f"{obj_src}[{repr(mem)}]"

    def _gen_call(self, call: expressions.FuncCall) -> str:
        callee = call.callee
        args_src = ", ".join(self._gen_expr(a) for a in call.arguments)
        if isinstance(callee, expressions.Identifier):
            if callee.name == "print":
                return f"print({args_src})"
            if callee.name == "len":
                return f"len({args_src})"
            return f"{callee.name}({args_src})"
        return f"{self._gen_expr(callee)}({args_src})"

    def _gen_list_literal(self, lit: expressions.LiteralList) -> str:
        elems = ", ".join(self._gen_expr(e) for e in lit.elements)
        return f"[{elems}]"

    def _gen_struct_literal(self, lit: expressions.StructLiteral) -> str:
        items = ", ".join(f"{repr(fi.name.name)}: {self._gen_expr(fi.value)}" for fi in lit.fields)
        return f"{{{items}}}"

    def _default_value_for_type(self, t: types.TypeSpecifier) -> str:
        if isinstance(t, types.BaseType):
            if t.name in self._structs:
                fields = self._structs[t.name]
                items = ", ".join(f"{repr(f)}: None" for f in fields)
                return "{" + items + "}"
            if t.name == "int":
                return "0"
            if t.name == "float":
                return "0.0"
            if t.name == "str":
                return "''"
            if t.name == "bool":
                return "False"
            return "None"
        if isinstance(t, types.ListType):
            return "[]"
        return "None"